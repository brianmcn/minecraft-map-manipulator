Ideas for individual videos or small projects:
 - quick stack to nearby chests (a la terraria)?  I guess it would involve huge tables, but, eh, why not? :)
    - also could QS to shulker boxes in own inventory
 - arrow to death point (on actionbar, goes away after you get within 5 blocks?)
 - look-teleporter (or grappling hook that moves over time)
 - 'aim-bot', e.g. turn player to face a specific target entity (or entity closest to his cursor)
 - drawing circles (e.g. using ^5 ^ ^ and rotating)
 - does anything change with mandelbrot? yes, no longer need cps (can just call forward, recurse forever? may be useful to test perf... surely final stack-unwind will lag? depth will add memory pressure?)
 - portal gun (or even not gun part, just spawn egg for orange/blue portal, can stay 'alive' even when you travel far away)
 - world pre-generator
 - shoot arrow replaces air with torch temporarily where it lands? (remote lighting)
=======================
command tutorial series
=======================
https://www.reddit.com/r/Lorgon111/comments/4k9ysb/learning_command_blocks_tutorial_series_playlist/

pseudocode for some ideas, before refining into commands?
possibly complete different order, start with data get, execute if, say, summon, ...
could do stuff like OnGround:0b/1b, sheep Sheared:0b,Color:0b ... Pos[x,y,z], ...
/execute if entity @e[type=sheep,nbt={Color:8b}] run say hi
small program ideas:
 - eventually quick-and-dirty version of look-teleporter
 - arrow to death point
 - can pose armor stand angles dynamically now, e.g. 3 player axes control 3 pose angles could be fun...
		/data merge entity @e[type=armor_stand,limit=1] {ShowArms:1b,Pose:{LeftArm:[0.0f,0.0f,0.0f]}}
		execute store result entity @e[type=armor_stand,limit=1] Pose.LeftArm[0] float 8.0 run data get entity @p Pos[0] 1.0



 (possibly see http://jragoncommands.weebly.com/tutorials.html for ideas)
 general topic-area list
  - possibly some notes/philosophy for those coming from previous versions (e.g. about command blocks, fake-player scores, ...) as well as need to streamline (may be many ways to do something, pick one most useful one)
  - a sense of the bounds; some things are possible, and some things are not... the bounds are kinda arbitrary and must be learned through experience
  - setup (see prev series)
  - sender (who) and location (where) and function/command (what).... execute as pig say hi; execute at cow setblock stone (is there a good something other than 'say' that differs by 'who'? yes, facing ^ ^ ^1, maybe also 'read my health' or something)
       yeah, imagining in first episode typing commands to summon a NoAI pig, a NoAI horse with a different rotation, and then running commands like function say_health as them or setblock at them
	   talk abut the concepts, while showing un-as-yet-explained commands on the screen
  - coordinates (F3 debug screen, xyz, facing rotations, ~~~, ^^^, /setblock, /teleport)
  - entities (/summon, /kill, Tags:[], /tag, /data get entity, /data merge entity, wiki)
       aside: should I always have a long-lived entity tagged temp, for various debugging etc?
  - selectors
  - scoreboard (ent-value pairs, sidebar display, selector test) 
       aside: global variable philosophy, fake players in one objective (trade-offs, maybe faster lookup), 
	          versus a single score entity in many objectives (good: scales for sidebar display, usable in selectors, maybe a little slower lookup if not uuid)
  - /execute (sender&location; if, unless, as, at, offset, align, store-result)
  - functions (datapack mechanics, subroutine call control flow behavior and sender-location behavior)
  - repeating command block
  - minecraft:tick loop, time delays
  - JSON text, /tellraw, clickable signs
  - advancements (e.g. test biome)
  - blocks, blockstates & nbt []{}, and /data get block, data merge block, /replaceitem rather than /data for "inventories"
  - performance?
  - debugging (a useful helper might be "print_the_at" which summons an entity (or tp's an existing entity ~ ~ ~) and data gets its Pos to show you what the current "at" is)
  - "Minecraft stuff" (useful pokable entity data, physics, ...?)


===================
GENERAL PROGRAMMING
===================
apparently no trampolines needed, functions can recurse forever?

TODO work out an example like this (entity-less loop over an area):
	------------
	so i guess if I want to loop over an area of rows x cols, i init some variables with the values i want, and then have a function like 'do_row' and 'do_square' which are something like
	scoreboard players remove @p rows 1
	execute if entity @p[scores={rows=1..}] offset ~1 ~ ~ run function ns:do_row
	function ns:do_square

	scoreboard players remove @p cols 1
	execute if entity @p[scores={cols=1..}] offset ~ ~ ~1 run function ns:do_square
	setblock ~ ~ ~ stone   // or something like #call:thingy, and you can subrscribe to thingy with your receiver and guard it with e.g. if entity @s[tag=iWasTheCaller] ...

	maybe?  i guess I should just try it
	[10:39 PM] Lorgon111: that's not quite right, but close-ish i think
	-----------

think about skylinerw's "else feature"
before a 'switch', set a global flag, condition each branch on the flag, and first instruction of each called branch function unsets the flag
it's a transaction, yes? safe?
annoying that caller and callee have to coordinate, but seems simple and workable?

Note: what is behavior if #base:group calls child1:run which disables child1/child2?
answer: if fully-enabled order is {base,child1,child2}, if child1 calls "disable child2" then 
	(1) child2 still runs this tick and 
	(2) there is a noticeable latency at disable-time, suggesting enable/disable are "heavy"

https://minecraft.gamepedia.com/1.13/Flattening
https://gist.github.com/Dinnerbone/943fbcd763c19be188ed6b72a12d7e65
https://www.reddit.com/user/Dinnerbone/comments/6l6e3d/a_completely_incomplete_super_early_preview_of/

can we get arrays now by reading/writing? no because paths (e.g. Pos[2]) are still hardcoded...
can have arrays using e.g. array of structure blocks in the world and poking their PosX nbt data or something.

'the carets' give us easy sin/cos/tan, but we still don't have easy arcsin/arccos/arctan... MCPE's 'facing' gives that

should I always have a long-lived entity tagged temp & uuid'd, for various debugging etc? D-E-B-0-6?

how to do moral equivalent of 'testfor' results now: execute store result score @s NumPlayers if entity @a

Things to test in snapshot

    TODO verify "at @e" will loop, that is, perform the chained command for each entity
    same for 'as'
    but not for 'if/unless'

    understand data packs, how to turn off e.g. vanilla advancements/crafting

	cool trick to see if you're in the top-half of an oak_slab block (note that dx,dy,dz selectors test against entity hitbox, not your exact coords)
	/execute at @s if block ~ ~ ~ minecraft:oak_slab[type=bottom] align y offset ~ ~0.75 ~ run say @s[distance=..0.25]

# make a snowball turn into fallingsand block
# client only gets original summon info, so use 'barrier' so block is invisible to client, else they see falling sand fall from their face
execute at @e[type=snowball,tag=] run summon falling_block ~ ~ ~ {BlockState:{Name:"minecraft:barrier"},Time:1,Tags:["newfb"],Motion:[0.1,0.1,0.1]}
execute store result entity @e[tag=newfb,limit=1] Pos[0] double 0.001 run data get entity @e[type=snowball,tag=,limit=1] Pos[0] 1000.0
execute store result entity @e[tag=newfb,limit=1] Pos[1] double 0.001 run data get entity @e[type=snowball,tag=,limit=1] Pos[1] 1000.0
execute store result entity @e[tag=newfb,limit=1] Pos[2] double 0.001 run data get entity @e[type=snowball,tag=,limit=1] Pos[2] 1000.0
execute store result entity @e[tag=newfb,limit=1] Motion[0] double 0.001 run data get entity @e[type=snowball,tag=,limit=1] Motion[0] 1000.0
execute store result entity @e[tag=newfb,limit=1] Motion[1] double 0.001 run data get entity @e[type=snowball,tag=,limit=1] Motion[1] 1000.0
execute store result entity @e[tag=newfb,limit=1] Motion[2] double 0.001 run data get entity @e[type=snowball,tag=,limit=1] Motion[2] 1000.0
# change to block we want to end up with
data merge entity @e[tag=newfb,limit=1] {BlockState:{Name:"minecraft:gravel"}}
tag @e[type=snowball,tag=] add processed
tag @e[tag=newfb] remove newfb
# falling_block seems to have different physics than snowball at landing; since block is invisible while thrown anyway, makes more sense just to find last air block snowball exists in and just replace it probably


=========
E&T ideas
=========
think about survival waypoints idea...
wubbi https://www.youtube.com/watch?v=WCJRTd7Otq8 has a nice one
basic idea:
 - have a room with lots of clickable signs (go to waypoint N)
 - player can add own signs for names if desired
 - spawn egg or whatnot to place new waypoint (crafting/found materials?), will have AS with particles or whatnot, will store coords in scoreboard in fixed (non-entity?) slots (WayX01, WayY01, ... WayX99...)
 - when player stays in particles for more than 3s or whatever, brings to tp room
 - could 'delete' waypoint by having e.g. WayYnn==-1 to mark as 'unused', and clickable sign to 'forget' it? hm, but how delete the entity there... i guess it could delete self after check if exist based on scores

Unlocking recipes, maybe make a tech tree, and finding dungeons give ingredients to unlock portions of tree?
Like previous season, but with choice rather than linear (craft a knowledge book to 'choose')
possible things to need to learn (from previous) include: Furnace, Bed, Anvil, I. Armor, Bow, D. Armor, Bucket, Shield, D. Pick
others: enchant table, brewing stand (nether chest item to get recipe?), iron pick, all hoes, stone tools, 

todo recipe for throwable light, like torch + snowball + slimeball?

from old swirl notes:
	tech tree: no early pickaxe? f&s rather than sword/axe? no torch recipe? villagers sell 3 choice of recipe? late bow/shield? early tnt? what foods? armor logic?
	recipes: iron nuggets on tip stone pick -> weak iron pick, can mine gold; iron/gold ore smelt furance -> nuggets; iron/gold nuggets in recipe for chain mail

	terrain changes: depthbasesize up (to like 13) and sea level up (to like 100) gives more underground (also bring ore distributions up higher), but
	 - connectedness of caves/mineshafts below ground is still a big issue... maybe i carve out more air? idea to compute skeleton, and then have 'ends' search spherically for a 
	   different airspace CC within like 10 blocks or something, and if found, connect with an air tunnel? also need a way to open up more tunnels to surface...
	 - or maybe can get more with other settings, e.g. increase lower limit scale to 850? 3000? even upper height limit 3000? ...
		 - lower limit down to 70 makes amplified-like crazy overhangy tall bits; upper limit down to 170, similar, not as many caves? both down to 212, not much land above sea level
	 - or maybe can overlay cave air from a separate world with even larger cave-height, which creates more holes to surface and adds more caves?
		 - yeah, depthbase 20, sea level 150, turn off mineshafts/lakes/dungeons/ravines, just grab cave air, overlay, seems plausible
	(could replace large pockets of dirt/gravel/ore with glass/air, as another possible way to 'connect' caves?)
	render's idea for advancements as 'tome of knowledge', e.g. tab for 'yellow wool', names that area, shows how many emeralds or other side objectives there are, etc.
	render's sprint mechanic - if player not near any hostile mobs (could mark all hostiles as spawn in? and check 1Hz? dist>16?) for some time (10s?) then give sprint back?
	render's consumable idea - craft tulip into food, then e.g. can give non-renewable food 'in world' rather than in a chest; also e.g. shrubs drop sticks, starve of wood, have craft table in environment
	using glass/panes tactically is fun




Figure out custom terrain to use

QFE? need master list of all items, then curate for obtainable; rest should be straighforward?
also the qfe could be an existing teleporter once i unlock first teleporter; first visit to QFE room could actually start the qfe game?

==============
MinecraftBINGO
==============
cut the tutorial for good
ignore custom modes, and item chests in initial version
bug: https://www.reddit.com/r/minecraftbingo/comments/74sd7m/broken_seed_spawn_in_a_waterfall_and_die_in_a_wall/
bugs & ideas from top of old file


feature ideas:
 x beacon at spawn
 x randomly put people on 1/2/3/4 teams
 - 'blind' covered play (on_newcard, on_got_squareNM, what else? need UI to turn on & off (data pack enabling?) and maybe UI to uncover card at end?)
 - use achievement toasts rather than chat for got-item notifications?
 - enable-able datapacks mean e.g. alternate loot tables could be turned on, etc?
 - custom configs done as separate data packs? out-of-band changes/extensions?
    - on-start/on-respawn is one type of simple customization that maybe could be in datapack
    - lockout, 'blind-covered', other bingo-game mechanics updates are more baked in, hm...
 - call out 'sniper bingo' (score exactly 5)
 - 20-no-bingo? mkg points out you can 'lose' after e.g. 45 mins, only downside... could play "20-no-bingo-else-blackout" on the subreddit maybe
 - 'visually specify a plan', e.g. in lobby before start, mark items on card (for bingo, alt, 20-no-bingo, ...)?
      - what is gui to interact? how would it appear on the card? make any sense for multiplayer? ...
new items:
 x arrow as bone alternative
 x detector rail and activator rails as rail alternative
 x redstone torch as easier repeater?
 x water/lava bucket? (would interact with tool-like gameplay a little, but not bad) is very easy... cauldron alternatives? lava yes, water no

architecture

helper functions
 x PRNG
 x make new card (clone art, setup checker command blocks)
 x finalize prior game (clear inv, feed/heal, tp all to lobby, ...)
 x make new seeded card
 x make new random card
 x ensure card updated (player holding map at spawn)
 x begin a game (lots of logic here...)
 x check for bingo (5-in-a-row logic)
 - team-got-an-item (announce, add score, check for win/lockout)
 x various 'win' announcements/fireworks/scoreboard
 x worldborder timekeeper logic (compute actual seconds)
 x find spawn point based on seed (maybe different logic/implementation from now? yes, binary search a list of larger choices...)
 x compute lockout goal

blocks
 x art assets
 - ?lobby? (or code that write it?)
 - 'branding' on the map (bingo by lorgon, bDia)
 - history/books/donations/etc

ongoing per-tick code
 x updating game time when game in progress (seconds on scoreboard, MM:SS on statusbar)
 x check for players who drop map when game in progress (kill map, tag player, invoke TP sequence)
 x check for players with no more maps to give more
 x check for anyone with a trigger home score (to tp back to lobby)
 x check for on-respawn when game in progress (test for live player with death count, run on-respawn code, reset deaths)
 x check for 25-mins passed when game in progress

setup
 - gamerules
 x scoreboard objectives created
 x constants initialized
 - ?build lobby?
 x any permanent entities

discarded ideas:
 
 - new item: water bottle as alt bottle? no, has NBT (id:minecraft:potion,tag:{Potion:minecraft:water})
 - new item: salmon as harder cod? (old bingo fish was 82%, cod is 50%, salmon is 21%, that is probably too hard)
 
 - end gateway with perm age as way to beacon without beacon
		execute @e[name=Floaty,tag=Zam_Beam] ~ ~ ~ setblock ~ ~ ~ end_gateway 0 {Age:100}
		(repeat) execute @e[name=Floaty,tag=Zam_Beam] ~ ~ ~ blockdata ~ ~ ~ {Age:100}
   the @e is too expensive to run every tick just for a slightly better visual

 - suggested to fill map update room head with water IFF player's head is in water at moment of teleport :P  
        there are other exploits (e.g. in multiplayer, if skeleton shoots at you, drop map and arrow sails by), don't try to fix them all


