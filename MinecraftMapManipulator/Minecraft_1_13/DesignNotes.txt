Ideas for individual videos or small projects:
 - quick stack to nearby chests (a la terraria)?  I guess it would involve huge tables, but, eh, why not? :)
    - also could QS to shulker boxes in own inventory
 - arrow to death point (on actionbar, goes away after you get within 5 blocks?)
 - look-teleporter (or grappling hook that moves over time)
 - 'aim-bot', e.g. turn player to face a specific target entity (or entity closest to his cursor)
 - drawing circles (e.g. using ^5 ^ ^ and rotating)
 - does anything change with mandelbrot? yes, no longer need cps (can just call forward, recurse forever? may be useful to test perf... surely final stack-unwind will lag? depth will add memory pressure?)
 - portal gun (or even not gun part, just spawn egg for orange/blue portal, can stay 'alive' even when you travel far away)
 - world pre-generator
 - shoot arrow replaces air with torch temporarily where it lands? (remote lighting)
=======================
command tutorial series
=======================
https://www.reddit.com/r/Lorgon111/comments/4k9ysb/learning_command_blocks_tutorial_series_playlist/

pseudocode for some ideas, before refining into commands?
possibly complete different order, start with data get, execute if, say, summon, ...
could do stuff like OnGround:0b/1b, sheep Sheared:0b,Color:0b ... Pos[x,y,z], ...
/execute if entity @e[type=sheep,nbt={Color:8b}] run say hi
small program ideas:
 - eventually quick-and-dirty version of look-teleporter
 - arrow to death point
 - can pose armor stand angles dynamically now, e.g. 3 player axes control 3 pose angles could be fun...
		/data merge entity @e[type=armor_stand,limit=1] {ShowArms:1b,Pose:{LeftArm:[0.0f,0.0f,0.0f]}}
		execute store result entity @e[type=armor_stand,limit=1] Pose.LeftArm[0] float 8.0 run data get entity @p Pos[0] 1.0



 (possibly see http://jragoncommands.weebly.com/tutorials.html for ideas)
 general topic-area list
  - possibly some notes/philosophy for those coming from previous versions (e.g. about command blocks, fake-player scores, ...) as well as need to streamline (may be many ways to do something, pick one most useful one)
  - a sense of the bounds; some things are possible, and some things are not... the bounds are kinda arbitrary and must be learned through experience
  - setup (see prev series; stuff like f3, keyboard shortcuts, gamemodes, F3+N, how to make rr world, ...)
  - sender (who) and location (where) and function/command (what).... execute as pig say hi; execute at cow setblock stone (is there a good something other than 'say' that differs by 'who'? yes, facing ^ ^ ^1, maybe also 'read my health' or something)
       yeah, imagining in first episode typing commands to summon a NoAI pig, a NoAI horse with a different rotation, and then running commands like function say_health as them or setblock at them
	   talk abut the concepts, while showing un-as-yet-explained commands on the screen
  - coordinates (F3 debug screen, xyz, facing rotations, ~~~, ^^^, /setblock, /teleport)
       make thingy to fly in direction looking with tp ^ ^ ^0.05 or whatever, maybe put block in sky at y=100 above slimes or minecart chests or something, as simple examples? 
			coud cycling difficulty every 2 ticks quickly find slime chunks that way? or cycle every time find a slime?
  - entities (/summon, /kill, Tags:[], /tag, /data get entity, /data merge entity, wiki)
       aside: should I always have a long-lived entity tagged temp, for various debugging etc?
  - selectors
  - scoreboard (ent-value pairs, sidebar display, selector test) 
       aside: global variable philosophy, fake players in one objective (trade-offs, maybe faster lookup), 
	          versus a single score entity in many objectives (good: scales for sidebar display, usable in selectors, maybe a little slower lookup if not uuid)
  - /execute (sender&location; if, unless, as, at, offset, align, store-result)
  - functions (datapack mechanics, subroutine call control flow behavior and sender-location behavior)
  - repeating command block
  - minecraft:tick loop, time delays
  - JSON text, /tellraw, clickable signs
  - advancements (e.g. test biome)
  - blocks, blockstates & nbt []{}, and /data get block, data merge block, /replaceitem rather than /data for "inventories"
  - performance?
  - debugging (a useful helper might be "print_the_at" which summons an entity (or tp's an existing entity ~ ~ ~) and data gets its Pos to show you what the current "at" is)
  - "Minecraft stuff" (useful pokable entity data, physics, ...?)


===================
GENERAL PROGRAMMING
===================
apparently no trampolines needed, functions can recurse forever?

TODO work out an example like this (entity-less loop over an area):
	------------
	so i guess if I want to loop over an area of rows x cols, i init some variables with the values i want, and then have a function like 'do_row' and 'do_square' which are something like
	scoreboard players remove @p rows 1
	execute if entity @p[scores={rows=1..}] offset ~1 ~ ~ run function ns:do_row
	function ns:do_square

	scoreboard players remove @p cols 1
	execute if entity @p[scores={cols=1..}] offset ~ ~ ~1 run function ns:do_square
	setblock ~ ~ ~ stone   // or something like #call:thingy, and you can subrscribe to thingy with your receiver and guard it with e.g. if entity @s[tag=iWasTheCaller] ...

	maybe?  i guess I should just try it
	[10:39 PM] Lorgon111: that's not quite right, but close-ish i think
	-----------

think about skylinerw's "else feature"
before a 'switch', set a global flag, condition each branch on the flag, and first instruction of each called branch function unsets the flag
it's a transaction, yes? safe?
annoying that caller and callee have to coordinate, but seems simple and workable?

Note: what is behavior if #base:group calls child1:run which disables child1/child2?
answer: if fully-enabled order is {base,child1,child2}, if child1 calls "disable child2" then 
	(1) child2 still runs this tick and 
	(2) there is a noticeable latency at disable-time, suggesting enable/disable are "heavy"

https://minecraft.gamepedia.com/1.13/Flattening
https://gist.github.com/Dinnerbone/943fbcd763c19be188ed6b72a12d7e65
https://www.reddit.com/user/Dinnerbone/comments/6l6e3d/a_completely_incomplete_super_early_preview_of/
https://github.com/PepijnMC/Minecraft/tree/master/Data
https://github.com/skylinerw/guides


can we get arrays now by reading/writing? no because paths (e.g. Pos[2]) are still hardcoded...
can have arrays using e.g. array of structure blocks in the world and poking their PosX nbt data or something.

'the carets' give us easy sin/cos/tan, but we still don't have easy arcsin/arccos/arctan... MCPE's 'facing' gives that

should I always have a long-lived entity tagged temp & uuid'd, for various debugging etc? D-E-B-0-6?

how to do moral equivalent of 'testfor' results now: execute store result score @s NumPlayers if entity @a

Things to test in snapshot

    TODO verify "at @e" will loop, that is, perform the chained command for each entity
    same for 'as'
    but not for 'if/unless'

    understand data packs, how to turn off e.g. vanilla advancements/crafting

	cool trick to see if you're in the top-half of an oak_slab block (note that dx,dy,dz selectors test against entity hitbox, not your exact coords)
	/execute at @s if block ~ ~ ~ minecraft:oak_slab[type=bottom] align y offset ~ ~0.75 ~ run say @s[distance=..0.25]

# make a snowball turn into fallingsand block
# client only gets original summon info, so use 'barrier' so block is invisible to client, else they see falling sand fall from their face
execute at @e[type=snowball,tag=] run summon falling_block ~ ~ ~ {BlockState:{Name:"minecraft:barrier"},Time:1,Tags:["newfb"],Motion:[0.1,0.1,0.1]}
execute store result entity @e[tag=newfb,limit=1] Pos[0] double 0.001 run data get entity @e[type=snowball,tag=,limit=1] Pos[0] 1000.0
execute store result entity @e[tag=newfb,limit=1] Pos[1] double 0.001 run data get entity @e[type=snowball,tag=,limit=1] Pos[1] 1000.0
execute store result entity @e[tag=newfb,limit=1] Pos[2] double 0.001 run data get entity @e[type=snowball,tag=,limit=1] Pos[2] 1000.0
execute store result entity @e[tag=newfb,limit=1] Motion[0] double 0.001 run data get entity @e[type=snowball,tag=,limit=1] Motion[0] 1000.0
execute store result entity @e[tag=newfb,limit=1] Motion[1] double 0.001 run data get entity @e[type=snowball,tag=,limit=1] Motion[1] 1000.0
execute store result entity @e[tag=newfb,limit=1] Motion[2] double 0.001 run data get entity @e[type=snowball,tag=,limit=1] Motion[2] 1000.0
# change to block we want to end up with
data merge entity @e[tag=newfb,limit=1] {BlockState:{Name:"minecraft:gravel"}}
tag @e[type=snowball,tag=] add processed
tag @e[tag=newfb] remove newfb
# falling_block seems to have different physics than snowball at landing; since block is invisible while thrown anyway, makes more sense just to find last air block snowball exists in and just replace it probably

==============
MinecraftBINGO
==============
cut the tutorial for good
ignore custom modes, and item chests in initial version
bug: https://www.reddit.com/r/minecraftbingo/comments/74sd7m/broken_seed_spawn_in_a_waterfall_and_die_in_a_wall/
bugs & ideas from top of old file


feature ideas:
 x beacon at spawn
 x randomly put people on 1/2/3/4 teams
 - 'blind' covered play (on_newcard, on_got_squareNM, what else? need UI to turn on & off (data pack enabling?) and maybe UI to uncover card at end?)
 - use achievement toasts rather than chat for got-item notifications?
 - enable-able datapacks mean e.g. alternate loot tables could be turned on, etc?
 - custom configs done as separate data packs? out-of-band changes/extensions?
    - on-start/on-respawn is one type of simple customization that maybe could be in datapack
    - lockout, 'blind-covered', other bingo-game mechanics updates are more baked in, hm...
 - call out 'sniper bingo' (score exactly 5)
 - 20-no-bingo? mkg points out you can 'lose' after e.g. 45 mins, only downside... could play "20-no-bingo-else-blackout" on the subreddit maybe
 - 'visually specify a plan', e.g. in lobby before start, mark items on card (for bingo, alt, 20-no-bingo, ...)?
      - what is gui to interact? how would it appear on the card? make any sense for multiplayer? ...
new items:
 x arrow as bone alternative
 x detector rail and activator rails as rail alternative
 x redstone torch as easier repeater?
 x water/lava bucket? (would interact with tool-like gameplay a little, but not bad) is very easy... cauldron alternatives? lava yes, water no

architecture

helper functions
 x PRNG
 x make new card (clone art, setup checker command blocks)
 x finalize prior game (clear inv, feed/heal, tp all to lobby, ...)
 x make new seeded card
 x make new random card
 x ensure card updated (player holding map at spawn)
 x begin a game (lots of logic here...)
 x check for bingo (5-in-a-row logic)
 - team-got-an-item (announce, add score, check for win/lockout)
 x various 'win' announcements/fireworks/scoreboard
 x worldborder timekeeper logic (compute actual seconds)
 x find spawn point based on seed (maybe different logic/implementation from now? yes, binary search a list of larger choices...)
 x compute lockout goal

blocks
 x art assets
 - ?lobby? (or code that write it?)
 - 'branding' on the map (bingo by lorgon, bDia)
 - history/books/donations/etc

ongoing per-tick code
 x updating game time when game in progress (seconds on scoreboard, MM:SS on statusbar)
 x check for players who drop map when game in progress (kill map, tag player, invoke TP sequence)
 x check for players with no more maps to give more
 x check for anyone with a trigger home score (to tp back to lobby)
 x check for on-respawn when game in progress (test for live player with death count, run on-respawn code, reset deaths)
 x check for 25-mins passed when game in progress

setup
 - gamerules
 x scoreboard objectives created
 x constants initialized
 - ?build lobby?
 x any permanent entities

discarded ideas:
 
 - new item: water bottle as alt bottle? no, has NBT (id:minecraft:potion,tag:{Potion:minecraft:water})
 - new item: salmon as harder cod? (old bingo fish was 82%, cod is 50%, salmon is 21%, that is probably too hard)
 
 - end gateway with perm age as way to beacon without beacon
		execute @e[name=Floaty,tag=Zam_Beam] ~ ~ ~ setblock ~ ~ ~ end_gateway 0 {Age:100}
		(repeat) execute @e[name=Floaty,tag=Zam_Beam] ~ ~ ~ blockdata ~ ~ ~ {Age:100}
   the @e is too expensive to run every tick just for a slightly better visual

 - suggested to fill map update room head with water IFF player's head is in water at moment of teleport :P  
        there are other exploits (e.g. in multiplayer, if skeleton shoots at you, drop map and arrow sails by), don't try to fix them all


