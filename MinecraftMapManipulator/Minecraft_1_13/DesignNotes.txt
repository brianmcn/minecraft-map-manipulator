Ideas for individual videos or small projects:
 - quick stack to nearby chests (a la terraria)?  I guess it would involve huge tables, but, eh, why not? :)
    - also could QS to shulker boxes in own inventory
 - arrow to death point (on actionbar, goes away after you get within 5 blocks?)
 - look-teleporter (or grappling hook that moves over time)
 - 'aim-bot', e.g. turn player to face a specific target entity (or entity closest to his cursor)
 - drawing circles (e.g. using ^5 ^ ^ and rotating)
 - does anything change with mandelbrot? yes, no longer need cps (can just call forward, recurse forever? may be useful to test perf... surely final stack-unwind will lag? depth will add memory pressure?)
 - portal gun (or even not gun part, just spawn egg for orange/blue portal, can stay 'alive' even when you travel far away)
 - world pre-generator
 - shoot arrow replaces air with torch temporarily where it lands? (remote lighting)
 - spectator over-shoulder-cam?



=======================
command tutorial series
=======================
https://www.reddit.com/r/Lorgon111/comments/4k9ysb/learning_command_blocks_tutorial_series_playlist/

pseudocode for some ideas, before refining into commands?
possibly complete different order, start with data get, execute if, say, summon, ...
could do stuff like OnGround:0b/1b, sheep Sheared:0b,Color:0b ... Pos[x,y,z], ...
/execute if entity @e[type=sheep,nbt={Color:8b}] run say hi
small program ideas:
 - eventually quick-and-dirty version of look-teleporter
 - arrow to death point
 - can pose armor stand angles dynamically now, e.g. 3 player axes control 3 pose angles could be fun...
		/data merge entity @e[type=armor_stand,limit=1] {ShowArms:1b,Pose:{LeftArm:[0.0f,0.0f,0.0f]}}
		execute store result entity @e[type=armor_stand,limit=1] Pose.LeftArm[0] float 8.0 run data get entity @p Pos[0] 1.0



 (possibly see http://jragoncommands.weebly.com/tutorials.html for ideas)
 general topic-area list
  - possibly some notes/philosophy for those coming from previous versions (e.g. about command blocks, fake-player scores, ...) as well as need to streamline (may be many ways to do something, pick one most useful one)
  - a sense of the bounds; some things are possible, and some things are not (e.g. coords of block last mined)... the bounds are kinda arbitrary and must be learned through experience
  - setup (see prev series; stuff like f3, keyboard shortcuts, gamemodes, F3+N, how to make rr world, ...)
  - sender (who) and location (where) and facing/anchoring (?how?which-way?) and function/command (what).... execute as pig say hi; execute at cow setblock stone (is there a good something other than 'say' that differs by 'who'? yes, facing ^ ^ ^1, maybe also 'read my health' or something)
       yeah, imagining in first episode typing commands to summon a NoAI pig, a NoAI horse with a different rotation, and then running commands like function say_health as them or setblock at them
	   talk abut the concepts, while showing un-as-yet-explained commands on the screen
  - coordinates (F3 debug screen, xyz, facing rotations, absolute 1 2 3, relative ~~~, local ^^^, /setblock, /teleport)
       make thingy to fly in direction looking with tp ^ ^ ^0.05 or whatever; maybe cycle difficulty and put block in sky at y=100 above slimes (slow) or zombies (faster) or minecart chests or something, as simple examples? 
  - entities (/summon, /kill, Tags:[], /tag, /data get entity, /data merge entity, wiki)
       aside: should I always have a long-lived entity tagged temp, for various debugging etc?
	   fake player nbt like SelectedItem/SelectedItemSlot
  - blocks (name[properties]{blockentitynbt}) and items (name{nbt})
  - selectors
  - scoreboard (ent-value pairs, sidebar display, selector test) 
       aside: global variable philosophy, fake players in one objective (trade-offs, maybe faster lookup), 
	          versus a single score entity in many objectives (good: scales for sidebar display, usable in selectors, maybe a little slower lookup if not uuid)
  - /execute (sender&location; if, unless, as, at, offset, align, store-result)
  - functions (datapack mechanics, subroutine call control flow behavior and sender-location behavior)
  - repeating command block
  - minecraft:tick loop, time delays
  - JSON text, /tellraw, clickable signs
  - advancements (e.g. test biome)
  - blocks, blockstates & nbt []{}, and /data get block, data merge block, /replaceitem rather than /data for "inventories"
  - performance?
  - debugging (a useful helper might be "print_the_at" which summons an entity (or tp's an existing entity ~ ~ ~) and data gets its Pos to show you what the current "at" is)
         useful strategy is to 'reduce until it works, then build back up'
  - "Minecraft stuff" (useful pokable entity data, physics, ...?)


===================
GENERAL PROGRAMMING
===================
apparently no trampolines needed, functions can recurse forever?

Note: what is behavior if #base:group calls child1:run which disables child1/child2?
answer: if fully-enabled order is {base,child1,child2}, if child1 calls "disable child2" then 
	(1) child2 still runs this tick and 
	(2) there is a noticeable latency at disable-time, suggesting enable/disable are "heavy"

https://minecraft.gamepedia.com/1.13/Flattening
https://gist.github.com/Dinnerbone/943fbcd763c19be188ed6b72a12d7e65
https://www.reddit.com/user/Dinnerbone/comments/6l6e3d/a_completely_incomplete_super_early_preview_of/
https://github.com/PepijnMC/Minecraft/tree/master/Data
https://github.com/skylinerw/guides

can we get arrays now by reading/writing? no because paths (e.g. Pos[2]) are still hardcoded...
can have arrays using e.g. array of structure blocks in the world and poking their PosX nbt data or something.

'the carets' give us easy sin/cos/tan, 'facing' gives arcsin/arccos/arctan...

should I always have a long-lived entity tagged temp & uuid'd, for various debugging etc? D-E-B-0-6?

how to do moral equivalent of 'testfor' results now: execute store result score @s NumPlayers if entity @a

cool trick to see if you're in the top-half of an oak_slab block (note that dx,dy,dz selectors test against entity hitbox, not your exact coords)
  /execute at @s if block ~ ~ ~ minecraft:oak_slab[type=bottom] align y positioned ~ ~0.75 ~ run say @s[distance=..0.25]


==============
MinecraftBINGO
==============
bugs & ideas from top of old file

feature ideas:
 - enable-able datapacks mean e.g. alternate loot tables could be turned on, etc?
 - custom configs done as separate data packs? out-of-band changes/extensions?
    - on-start/on-respawn is one type of simple customization that maybe could be in datapack
    - lockout, 'blind-covered', other bingo-game mechanics updates are more baked in, hm...
 - call out 'sniper bingo' (score exactly 5)
 - 20-no-bingo? mkg points out you can 'lose' after e.g. 45 mins, only downside... could play "20-no-bingo-else-blackout" on the subreddit maybe
 - 'visually specify a plan', e.g. in lobby before start, mark items on card (for bingo, alt, 20-no-bingo, ...)?
      - what is gui to interact? how would it appear on the card? make any sense for multiplayer? ...
new items:
 x arrow as bone alternative
 x detector rail and activator rails as rail alternative
 x redstone torch as easier repeater?
 x water/lava bucket? (would interact with tool-like gameplay a little, but not bad) is very easy... cauldron alternatives? lava yes, water no

blocks
 x art assets
 - ?lobby? (or code that write it?)
 - 'branding' on the map (bingo by lorgon, bDia)
 - history/books/donations/etc

discarded ideas:
 - new item: water bottle as alt bottle? no, has NBT (id:minecraft:potion,tag:{Potion:minecraft:water})
 - new item: salmon as harder cod? (old bingo fish was 82%, cod is 50%, salmon is 21%, that is probably too hard)
 
 - end gateway with perm age as way to beacon without beacon
		execute @e[name=Floaty,tag=Zam_Beam] ~ ~ ~ setblock ~ ~ ~ end_gateway 0 {Age:100}
		(repeat) execute @e[name=Floaty,tag=Zam_Beam] ~ ~ ~ blockdata ~ ~ ~ {Age:100}
   the @e is too expensive to run every tick just for a slightly better visual

 - suggested to fill map update room head with water IFF player's head is in water at moment of teleport :P  
        there are other exploits (e.g. in multiplayer, if skeleton shoots at you, drop map and arrow sails by), don't try to fix them all

